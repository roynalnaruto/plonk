var searchIndex = JSON.parse('{\
"plonk":{"doc":"Permutations over Lagrange-bases for Oecumenical…","i":[[0,"commitment_scheme","plonk","Ideally we should cleanly abstract away the polynomial…",null,null],[0,"kzg10","plonk::commitment_scheme","Implementation of the KZG10 polynomial commitment scheme.",null,null],[3,"Proof","plonk::commitment_scheme::kzg10","Proof that a polynomial `p` was correctly evaluated at a…",null,null],[12,"commitment_to_witness","","This is a commitment to the witness polynomial.",0,null],[12,"evaluated_point","","This is the result of evaluating a polynomial at the point…",0,null],[12,"commitment_to_polynomial","","This is the commitment to the polynomial that you want to…",0,null],[3,"AggregateProof","","Proof that multiple polynomials were correctly evaluated…",null,null],[12,"commitment_to_witness","","This is a commitment to the aggregated witness polynomial.",1,null],[12,"evaluated_points","","These are the results of the evaluating each polynomial at…",1,null],[12,"commitments_to_polynomials","","These are the commitments to the polynomials which you…",1,null],[3,"Commitment","","Holds a commitment to a polynomial in a form of a…",null,null],[12,"0","","The commitment is a group element.",2,null],[0,"errors","","Errors related to KZG10",null,null],[4,"Error","plonk::commitment_scheme::kzg10::errors","Represents an error in SRS creation and or modification.",null,null],[13,"DegreeIsZero","","This error occurs when the user tries to create an SRS and…",3,null],[13,"TruncatedDegreeTooLarge","","This error occurs when the user tries to trim an srs to a…",3,null],[13,"TruncatedDegreeIsZero","","This error occurs when the user tries to trim an srs down…",3,null],[13,"PolynomialDegreeTooLarge","","This error occurs when the user tries to commit to a…",3,null],[13,"PolynomialDegreeIsZero","","This error occurs when the user tries to commit to a…",3,null],[0,"key","plonk::commitment_scheme::kzg10","Key module contains the ultilities and data structures…",null,null],[3,"VerifierKey","plonk::commitment_scheme::kzg10::key","Verifier Key is used to verify claims made about a…",null,null],[12,"g","","The generator of G1.",4,null],[12,"h","","The generator of G2.",4,null],[12,"beta_h","","\\\\beta times the above generator of G2.",4,null],[12,"prepared_h","","The generator of G2, prepared for use in pairings.",4,null],[12,"prepared_beta_h","","\\\\beta times the above generator of G2, prepared for use in…",4,null],[3,"ProverKey","","Prover key is used to commit to a polynomial which is…",null,null],[12,"powers_of_g","","Group elements of the form `{ \\\\beta^i G }`, where `i`…",5,null],[11,"max_degree","","Returns the maximum degree polynomial that you can commit…",5,[[]]],[11,"truncate","","Truncates the prover key to a lower max degree. Returns an…",5,[[],[["error",4],["proverkey",3],["result",4]]]],[11,"commit","","Commits to a polynomial returning the corresponding…",5,[[["polynomial",3]],[["commitment",3],["error",4],["result",4]]]],[11,"compute_single_witness","","For a given polynomial `p` and a point `z`, compute the…",5,[[["scalar",3],["polynomial",3]],["polynomial",3]]],[11,"open_single","","Creates an opening proof that a polynomial `p` was…",5,[[["scalar",3],["polynomial",3]],[["result",4],["proof",3],["error",4]]]],[11,"open_multiple","","Creates an opening proof that multiple polynomials were…",5,[[["scalar",3],["vec",3],["scalar",3],["transcriptprotocol",8]],[["aggregateproof",3],["result",4],["error",4]]]],[11,"check","","Checks that a polynomial `p` was evaluated at a point `z`…",4,[[["proof",3],["scalar",3]]]],[11,"batch_check","","Checks whether a batch of polynomials evaluated at…",4,[[["transcriptprotocol",8]]]],[0,"srs","plonk::commitment_scheme::kzg10","The Public Parameters can also be referred to as the…",null,null],[3,"PublicParameters","plonk::commitment_scheme::kzg10::srs","The Public Parameters can also be referred to as the…",null,null],[12,"commit_key","","Key used to generate proofs for composed circuits.",6,null],[12,"verifier_key","","Key used to verify proofs for composed circuits.",6,null],[11,"setup","","Setup generates the public parameters using a random…",6,[[],[["error",4],["result",4],["publicparameters",3]]]],[11,"trim","","Trim truncates the prover key to allow the prover to…",6,[[],[["result",4],["error",4]]]],[11,"max_degree","","Max degree specifies the largest polynomial that this…",6,[[]]],[11,"with_witness","plonk::commitment_scheme::kzg10","Initialises an `AggregatedProof` with the commitment to…",1,[[["commitment",3]],["aggregateproof",3]]],[11,"add_part","","Adds an evaluated point with the commitment to the…",1,[[]]],[11,"flatten","","Flattens an `AggregateProof` into a `Proof`. The…",1,[[["transcriptprotocol",8]],["proof",3]]],[11,"from_projective","","Builds a `Commitment` from a Bls12_381 `G1Projective` point.",2,[[["g1projective",3]]]],[11,"from_affine","","Builds a `Commitment` from a Bls12_381 `G1Affine` point.",2,[[["g1affine",3]]]],[11,"empty","","Builds an empty `Commitment` which is equivalent to the…",2,[[]]],[0,"constraint_system","plonk","The constraint System module stores the implementation of…",null,null],[0,"variable","plonk::constraint_system","This module holds the components needed in the Constraint…",null,null],[3,"Variable","plonk::constraint_system::variable","The value is a reference to the actual value that was…",null,null],[4,"WireData","","Stores the data for a specific wire in an arithmetic…",null,null],[13,"Left","","Left Wire of n\'th gate",7,null],[13,"Right","","Right Wire of n\'th gate",7,null],[13,"Output","","Output Wire of n\'th gate",7,null],[13,"Fourth","","Fourth Wire of n\'th gate",7,null],[0,"composer","plonk::constraint_system","The `Composer` is a Trait that is actually defining some…",null,null],[3,"StandardComposer","plonk::constraint_system::composer","A composer is a circuit builder and will dictate how a…",null,null],[12,"zero_var","","A zero variable that is a part of the circuit description.…",8,null],[11,"preprocess","","Computes the pre-processed polynomials So the verifier can…",8,[[["evaluationdomain",3],["proverkey",3],["transcriptprotocol",8]],["preprocessedcircuit",3]]],[11,"prove","","Prove will compute the pre-processed polynomials and…",8,[[["preprocessedcircuit",3],["proverkey",3],["transcriptprotocol",8]],["proof",3]]],[11,"circuit_size","","Returns the number of gates in the circuit",8,[[]]],[11,"new","","Generates a new empty `StandardComposer` with all of it\'s…",8,[[]]],[11,"split_tx_poly","","Split `t(X)` poly into 3 degree `n` polynomials.",8,[[["polynomial",3]]]],[11,"with_expected_size","","Creates a new circuit with an expected circuit size. This…",8,[[]]],[11,"add_input","","Add Input first calls the `Permutation` struct to generate…",8,[[["scalar",3]],["variable",3]]],[11,"add_gate","","Adds a width-3 add gate to the circuit, linking the…",8,[[["variable",3],["scalar",3]],["variable",3]]],[11,"add","","Adds a `big_addition_gate` with the left and right inputs…",8,[[["scalar",3]],["variable",3]]],[11,"big_add","","Adds a `big_addition_gate` with the left, right and fourth…",8,[[["scalar",3]],["variable",3]]],[11,"big_add_gate","","Adds a width-4 add gate to the circuit and it\'s…",8,[[["variable",3],["scalar",3]],["variable",3]]],[11,"mul_gate","","Adds a width-3 add gate to the circuit linking the product…",8,[[["variable",3],["scalar",3]],["variable",3]]],[11,"big_mul_gate","","Adds a width-4 `big_mul_gate` with the left, right and…",8,[[["variable",3],["scalar",3]],["variable",3]]],[11,"mul","","Adds a simple and basic addition to the circuit between to…",8,[[["variable",3],["scalar",3]],["variable",3]]],[11,"big_mul","","Adds a width-4 `big_mul_gate` with the left, right and…",8,[[["variable",3],["scalar",3]],["variable",3]]],[11,"poly_gate","","Adds a width-3 poly gate. This gate gives total freedom to…",8,[[["variable",3],["scalar",3]]]],[11,"constrain_to_constant","","Adds a gate which is designed to constrain a `Variable` to…",8,[[["variable",3],["scalar",3]]]],[11,"bool_gate","","Adds a boolean constraint (also known as binary…",8,[[["variable",3]],["variable",3]]],[11,"range_gate","","Adds a range-constraint gate that checks and constrains a…",8,[[["variable",3]]]],[11,"logic_xor_gate","","Adds a logical XOR gate that performs the XOR between two…",8,[[["variable",3]],["variable",3]]],[11,"logic_and_gate","","Adds a logical AND gate that performs the bitwise AND…",8,[[["variable",3]],["variable",3]]],[11,"assert_equal","","Asserts that two variables are the same",8,[[["variable",3]]]],[11,"add_dummy_constraints","","This function is used to add a blinding factor to the…",8,[[]]],[0,"fft","plonk","FFT module contains the tools needed by the Composer…",null,null],[3,"EvaluationDomain","plonk::fft","Defines a domain over which finite field (I)FFTs can be…",null,null],[12,"size","","The size of the domain.",9,null],[12,"log_size_of_group","","`log_2(self.size)`.",9,null],[12,"size_as_field_element","","Size of the domain as a field element.",9,null],[12,"size_inv","","Inverse of the size in the field.",9,null],[12,"group_gen","","A generator of the subgroup.",9,null],[12,"group_gen_inv","","Inverse of the generator of the subgroup.",9,null],[12,"generator_inv","","Multiplicative generator of the finite field.",9,null],[3,"Evaluations","","Stores a polynomial in evaluation form.",null,null],[12,"evals","","The evaluations of a polynomial over the domain `D`",10,null],[3,"Polynomial","","Polynomial represents a polynomial in coeffiient form.",null,null],[12,"coeffs","","The coefficient of `x^i` is stored at location `i` in…",11,null],[11,"new","","Construct a domain that is large enough for evaluations of…",9,[[],["option",4]]],[11,"compute_size_of_domain","","Return the size of a domain that is large enough for…",9,[[],["option",4]]],[11,"size","","Return the size of `self`.",9,[[]]],[11,"fft","","Compute a FFT.",9,[[],[["scalar",3],["vec",3]]]],[11,"fft_in_place","","Compute a FFT, modifying the vector in place.",9,[[["vec",3]]]],[11,"ifft","","Compute an IFFT.",9,[[],[["scalar",3],["vec",3]]]],[11,"ifft_in_place","","Compute an IFFT, modifying the vector in place.",9,[[["vec",3]]]],[11,"coset_fft","","Compute a FFT over a coset of the domain.",9,[[],[["scalar",3],["vec",3]]]],[11,"coset_fft_in_place","","Compute a FFT over a coset of the domain, modifying the…",9,[[["vec",3]]]],[11,"coset_ifft","","Compute an IFFT over a coset of the domain.",9,[[],[["scalar",3],["vec",3]]]],[11,"coset_ifft_in_place","","Compute an IFFT over a coset of the domain, modifying the…",9,[[["vec",3]]]],[11,"evaluate_all_lagrange_coefficients","","Evaluate all the lagrange polynomials defined by this…",9,[[["scalar",3]],[["scalar",3],["vec",3]]]],[11,"evaluate_vanishing_polynomial","","This evaluates the vanishing polynomial for this domain at…",9,[[["scalar",3]],["scalar",3]]],[11,"compute_vanishing_poly_over_coset","","Given that the domain size is `D` This function computes…",9,[[],["evaluations",3]]],[11,"elements","","Return an iterator over the elements of the domain.",9,[[],["elements",3]]],[11,"divide_by_vanishing_poly_on_coset_in_place","","The target polynomial is the zero polynomial in our…",9,[[]]],[11,"reindex_by_subdomain","","Given an index which assumes the first elements of this…",9,[[]]],[11,"mul_polynomials_in_evaluation_domain","","Perform O(n) multiplication of two polynomials that are…",9,[[],[["scalar",3],["vec",3]]]],[11,"from_vec_and_domain","","Construct `Self` from evaluations and a domain.",10,[[["evaluationdomain",3],["scalar",3],["vec",3]]]],[11,"interpolate_by_ref","","Interpolate a polynomial from a list of evaluations",10,[[],["polynomial",3]]],[11,"interpolate","","Interpolate a polynomial from a list of evaluations",10,[[],["polynomial",3]]],[11,"zero","","Returns the zero polynomial.",11,[[]]],[11,"is_zero","","Checks if the given polynomial is zero.",11,[[]]],[11,"from_coefficients_slice","","Constructs a new polynomial from a list of coefficients.",11,[[]]],[11,"from_coefficients_vec","","Constructs a new polynomial from a list of coefficients.",11,[[["scalar",3],["vec",3]]]],[11,"degree","","Returns the degree of the polynomial.",11,[[]]],[11,"evaluate","","Evaluates `self` at the given `point` in the field.",11,[[["scalar",3]],["scalar",3]]],[11,"rand","","Outputs a polynomial of degree `d` where each coefficient…",11,[[]]],[11,"ruffini","","Divides `self` by x-z using Ruffinis method",11,[[["scalar",3]],["polynomial",3]]],[0,"proof_system","plonk","proving system",null,null],[3,"PreProcessedCircuit","plonk::proof_system","`PreProcessedCircuit` is a data structure that holds the…",null,null],[12,"n","","The number of gates in the circuit",12,null],[12,"arithmetic","","Holds the polynomials, commitments and evaluations of all…",12,null],[12,"range","","Holds the polynomials, commitments and evaluations of all…",12,null],[12,"logic","","Holds the polynomials, commitments and evaluations of all…",12,null],[12,"permutation","","Holds the polynomials, commitments and evaluations related…",12,null],[3,"Proof","","A Proof is a composition of `Commitments` to the witness,…",null,null],[12,"a_comm","","Commitment to the witness polynomial for the left wires.",13,null],[12,"b_comm","","Commitment to the witness polynomial for the right wires.",13,null],[12,"c_comm","","Commitment to the witness polynomial for the output wires.",13,null],[12,"d_comm","","Commitment to the witness polynomial for the fourth wires.",13,null],[12,"z_comm","","Commitment to the permutation polynomial.",13,null],[12,"t_1_comm","","Commitment to the quotient polynomial.",13,null],[12,"t_2_comm","","Commitment to the quotient polynomial.",13,null],[12,"t_3_comm","","Commitment to the quotient polynomial.",13,null],[12,"t_4_comm","","Commitment to the quotient polynomial.",13,null],[12,"w_z_comm","","Commitment to the opening polynomial.",13,null],[12,"w_zw_comm","","Commitment to the shifted opening polynomial.",13,null],[12,"evaluations","","Subset of all of the evaluations added to the proof.",13,null],[11,"verify","","Performs the verification of a `Proof` returning a boolean…",13,[[["preprocessedcircuit",3],["verifierkey",3],["transcriptprotocol",8]]]],[0,"transcript","plonk","This is an extension over the Merlin Transcript which adds…",null,null],[8,"TranscriptProtocol","plonk::transcript","Transcript adds an abstraction over the Merlin transcript…",null,null],[10,"append_commitment","","Append a `commitment` with the given `label`.",14,[[["commitment",3]]]],[10,"append_scalar","","Append a `Scalar` with the given `label`.",14,[[["scalar",3]]]],[10,"challenge_scalar","","Compute a `label`ed challenge variable.",14,[[],["scalar",3]]],[10,"circuit_domain_sep","","Append domain separator for the circuit size.",14,[[]]],[0,"notes","plonk","This module is a self contained file which explains how…",null,null],[0,"commitment_schemes","plonk::notes","This module explains the inner workings of commitment…",null,null],[0,"permutation_arguments","","Contained within this module are the notes on how the…",null,null],[0,"snark_construction","","This module contains the methodology of how zk-SNARKS are…",null,null],[0,"prove_verify","","This module contains the notes on how the prover algorithm…",null,null],[0,"unbalanced_perm_args","","Contained within this module are the notes on how the…",null,null],[0,"kzg10_docs","","In this module we show how and why the KZG10 polynomial…",null,null],[11,"from","plonk::commitment_scheme::kzg10","",0,[[]]],[11,"into","","",0,[[]]],[11,"to_owned","","",0,[[]]],[11,"clone_into","","",0,[[]]],[11,"borrow","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"vzip","","",0,[[]]],[11,"from","","",1,[[]]],[11,"into","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"vzip","","",1,[[]]],[11,"from","","",2,[[]]],[11,"into","","",2,[[]]],[11,"to_owned","","",2,[[]]],[11,"clone_into","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"vzip","","",2,[[]]],[11,"from","plonk::commitment_scheme::kzg10::errors","",3,[[]]],[11,"into","","",3,[[]]],[11,"to_string","","",3,[[],["string",3]]],[11,"borrow","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"borrow_mut","","",3,[[]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"as_fail","","",3,[[],["fail",8]]],[11,"vzip","","",3,[[]]],[11,"from","plonk::commitment_scheme::kzg10::key","",4,[[]]],[11,"into","","",4,[[]]],[11,"to_owned","","",4,[[]]],[11,"clone_into","","",4,[[]]],[11,"borrow","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"try_into","","",4,[[],["result",4]]],[11,"borrow_mut","","",4,[[]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"vzip","","",4,[[]]],[11,"from","","",5,[[]]],[11,"into","","",5,[[]]],[11,"borrow","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"try_into","","",5,[[],["result",4]]],[11,"borrow_mut","","",5,[[]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"vzip","","",5,[[]]],[11,"from","plonk::commitment_scheme::kzg10::srs","",6,[[]]],[11,"into","","",6,[[]]],[11,"borrow","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"try_into","","",6,[[],["result",4]]],[11,"borrow_mut","","",6,[[]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"vzip","","",6,[[]]],[11,"from","plonk::constraint_system::variable","",15,[[]]],[11,"into","","",15,[[]]],[11,"to_owned","","",15,[[]]],[11,"clone_into","","",15,[[]]],[11,"borrow","","",15,[[]]],[11,"try_from","","",15,[[],["result",4]]],[11,"try_into","","",15,[[],["result",4]]],[11,"borrow_mut","","",15,[[]]],[11,"type_id","","",15,[[],["typeid",3]]],[11,"vzip","","",15,[[]]],[11,"from","","",7,[[]]],[11,"into","","",7,[[]]],[11,"to_owned","","",7,[[]]],[11,"clone_into","","",7,[[]]],[11,"borrow","","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"try_into","","",7,[[],["result",4]]],[11,"borrow_mut","","",7,[[]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"vzip","","",7,[[]]],[11,"from","plonk::constraint_system::composer","",8,[[]]],[11,"into","","",8,[[]]],[11,"borrow","","",8,[[]]],[11,"try_from","","",8,[[],["result",4]]],[11,"try_into","","",8,[[],["result",4]]],[11,"borrow_mut","","",8,[[]]],[11,"type_id","","",8,[[],["typeid",3]]],[11,"vzip","","",8,[[]]],[11,"from","plonk::fft","",9,[[]]],[11,"into","","",9,[[]]],[11,"to_owned","","",9,[[]]],[11,"clone_into","","",9,[[]]],[11,"borrow","","",9,[[]]],[11,"try_from","","",9,[[],["result",4]]],[11,"try_into","","",9,[[],["result",4]]],[11,"borrow_mut","","",9,[[]]],[11,"type_id","","",9,[[],["typeid",3]]],[11,"vzip","","",9,[[]]],[11,"from","","",10,[[]]],[11,"into","","",10,[[]]],[11,"to_owned","","",10,[[]]],[11,"clone_into","","",10,[[]]],[11,"borrow","","",10,[[]]],[11,"try_from","","",10,[[],["result",4]]],[11,"try_into","","",10,[[],["result",4]]],[11,"borrow_mut","","",10,[[]]],[11,"type_id","","",10,[[],["typeid",3]]],[11,"vzip","","",10,[[]]],[11,"from","","",11,[[]]],[11,"into","","",11,[[]]],[11,"to_owned","","",11,[[]]],[11,"clone_into","","",11,[[]]],[11,"borrow","","",11,[[]]],[11,"try_from","","",11,[[],["result",4]]],[11,"try_into","","",11,[[],["result",4]]],[11,"borrow_mut","","",11,[[]]],[11,"type_id","","",11,[[],["typeid",3]]],[11,"vzip","","",11,[[]]],[11,"from","plonk::proof_system","",12,[[]]],[11,"into","","",12,[[]]],[11,"borrow","","",12,[[]]],[11,"try_from","","",12,[[],["result",4]]],[11,"try_into","","",12,[[],["result",4]]],[11,"borrow_mut","","",12,[[]]],[11,"type_id","","",12,[[],["typeid",3]]],[11,"vzip","","",12,[[]]],[11,"from","","",13,[[]]],[11,"into","","",13,[[]]],[11,"borrow","","",13,[[]]],[11,"try_from","","",13,[[],["result",4]]],[11,"try_into","","",13,[[],["result",4]]],[11,"borrow_mut","","",13,[[]]],[11,"type_id","","",13,[[],["typeid",3]]],[11,"vzip","","",13,[[]]],[11,"into","plonk::constraint_system::variable","",15,[[]]],[11,"clone","plonk::commitment_scheme::kzg10::key","",4,[[],["verifierkey",3]]],[11,"clone","plonk::commitment_scheme::kzg10","",0,[[],["proof",3]]],[11,"clone","","",2,[[],["commitment",3]]],[11,"clone","plonk::constraint_system::variable","",15,[[],["variable",3]]],[11,"clone","","",7,[[],["wiredata",4]]],[11,"clone","plonk::fft","",9,[[],["evaluationdomain",3]]],[11,"clone","","",10,[[],["evaluations",3]]],[11,"clone","","",11,[[],["polynomial",3]]],[11,"default","plonk::commitment_scheme::kzg10","",2,[[]]],[11,"default","plonk::constraint_system::composer","",8,[[]]],[11,"eq","plonk::commitment_scheme::kzg10","",2,[[["commitment",3]]]],[11,"ne","","",2,[[["commitment",3]]]],[11,"eq","plonk::constraint_system::variable","",15,[[["variable",3]]]],[11,"ne","","",15,[[["variable",3]]]],[11,"eq","","",7,[[["wiredata",4]]]],[11,"ne","","",7,[[["wiredata",4]]]],[11,"eq","plonk::fft","",9,[[["evaluationdomain",3]]]],[11,"ne","","",9,[[["evaluationdomain",3]]]],[11,"eq","","",10,[[["evaluations",3]]]],[11,"ne","","",10,[[["evaluations",3]]]],[11,"eq","","",11,[[["polynomial",3]]]],[11,"ne","","",11,[[["polynomial",3]]]],[11,"eq","plonk::proof_system","",12,[[["preprocessedcircuit",3]]]],[11,"ne","","",12,[[["preprocessedcircuit",3]]]],[11,"eq","","",13,[[["proof",3]]]],[11,"ne","","",13,[[["proof",3]]]],[11,"deref","plonk::fft","",11,[[]]],[11,"deref_mut","","",11,[[]]],[11,"fmt","plonk::commitment_scheme::kzg10::errors","",3,[[["formatter",3]],["result",6]]],[11,"fmt","plonk::commitment_scheme::kzg10::key","",4,[[["formatter",3]],["result",6]]],[11,"fmt","","",5,[[["formatter",3]],["result",6]]],[11,"fmt","plonk::commitment_scheme::kzg10::srs","",6,[[["formatter",3]],["result",6]]],[11,"fmt","plonk::commitment_scheme::kzg10","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"fmt","plonk::constraint_system::variable","",15,[[["formatter",3]],["result",6]]],[11,"fmt","","",7,[[["formatter",3]],["result",6]]],[11,"fmt","plonk::constraint_system::composer","",8,[[["formatter",3]],["result",6]]],[11,"fmt","plonk::fft","",9,[[["formatter",3]],["result",6]]],[11,"fmt","","",10,[[["formatter",3]],["result",6]]],[11,"fmt","","",11,[[["formatter",3]],["result",6]]],[11,"fmt","plonk::proof_system","",12,[[["formatter",3]],["result",6]]],[11,"fmt","","",13,[[["formatter",3]],["result",6]]],[11,"fmt","plonk::commitment_scheme::kzg10::errors","",3,[[["formatter",3]],["result",6]]],[11,"neg","plonk::fft","",11,[[],["polynomial",3]]],[11,"add_assign","","",10,[[["evaluations",3]]]],[11,"add_assign","","",11,[[["polynomial",3]]]],[11,"add_assign","","",11,[[]]],[11,"sub_assign","","",10,[[["evaluations",3]]]],[11,"sub_assign","","",11,[[["polynomial",3]]]],[11,"mul_assign","","",10,[[["evaluations",3]]]],[11,"div_assign","","",10,[[["evaluations",3]]]],[11,"index","","",10,[[],["scalar",3]]],[11,"hash","plonk::constraint_system::variable","",15,[[]]],[11,"sum","plonk::fft","",11,[[]]],[11,"name","plonk::commitment_scheme::kzg10::errors","",3,[[],["option",4]]],[11,"cause","","",3,[[],[["option",4],["fail",8]]]],[11,"backtrace","","",3,[[],[["option",4],["backtrace",3]]]],[11,"serialize","plonk::commitment_scheme::kzg10::key","",4,[[],["result",4]]],[11,"serialize","","",5,[[],["result",4]]],[11,"serialize","plonk::commitment_scheme::kzg10::srs","",6,[[],["result",4]]],[11,"serialize","plonk::commitment_scheme::kzg10","",2,[[],["result",4]]],[11,"serialize","plonk::fft","",9,[[],["result",4]]],[11,"serialize","","",10,[[],["result",4]]],[11,"serialize","","",11,[[],["result",4]]],[11,"serialize","plonk::proof_system","",12,[[],["result",4]]],[11,"serialize","","",13,[[],["result",4]]],[11,"deserialize","plonk::commitment_scheme::kzg10::key","",4,[[],["result",4]]],[11,"deserialize","","",5,[[],["result",4]]],[11,"deserialize","plonk::commitment_scheme::kzg10::srs","",6,[[],["result",4]]],[11,"deserialize","plonk::commitment_scheme::kzg10","",2,[[],["result",4]]],[11,"deserialize","plonk::fft","",9,[[],["result",4]]],[11,"deserialize","","",10,[[],["result",4]]],[11,"deserialize","","",11,[[],["result",4]]],[11,"deserialize","plonk::proof_system","",12,[[],["result",4]]],[11,"deserialize","","",13,[[],["result",4]]]],"p":[[3,"Proof"],[3,"AggregateProof"],[3,"Commitment"],[4,"Error"],[3,"VerifierKey"],[3,"ProverKey"],[3,"PublicParameters"],[4,"WireData"],[3,"StandardComposer"],[3,"EvaluationDomain"],[3,"Evaluations"],[3,"Polynomial"],[3,"PreProcessedCircuit"],[3,"Proof"],[8,"TranscriptProtocol"],[3,"Variable"]]}\
}');
addSearchOptions(searchIndex);initSearch(searchIndex);